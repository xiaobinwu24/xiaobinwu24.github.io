---
layout: post
title:  "MYSQL 降低隔离级别，为什么能够减少锁的争用
date:   2024-11-22 09:19:41 +0800
categories: MYSQL
tags: [MYSQL]
---
![描述图片](/asset/img/1.png)
<audio controls autoplay>
  <source src="/asset/mp3/a2.mp3" type="audio/mpeg">
</audio>
# 降低隔离级别如何减少锁争用？

虽然 READ COMMITTED 和 REPEATABLE READ 的快照读本质上不依赖锁，但当前读和写操作仍然会使用锁，并且不同隔离级别对锁的使用策略不同。以下是降低隔离级别减少锁争用的主要原因：

### **1.1 间隙锁的使用差异**

在 **REPEATABLE READ** 下，为了防止幻读，InnoDB 会引入 **间隙锁（Gap Lock）** 或 **临键锁（Next-Key Lock）**。

- **间隙锁的作用：**
  - 在执行范围查询时（如 `SELECT ... FOR UPDATE` 或 `DELETE`），不仅锁定已有的行，还会锁定行与行之间的间隙，防止其他事务插入新数据。
  - 例如，查询 `id BETWEEN 100 AND 200` 时，`100` 到 `200` 之间的行和间隙都会被锁定。
- **READ COMMITTED：**
  - 不使用间隙锁，只锁定当前访问的记录。
  - 其他事务可以在查询范围内插入数据。

### **示例：间隙锁的影响**

```
sql复制代码-- 事务 1：
START TRANSACTION;
SELECT * FROM orders WHERE id > 10 FOR UPDATE;

-- 事务 2：
START TRANSACTION;
INSERT INTO orders (id, name) VALUES (11, 'new_order'); 
-- 在 REPEATABLE READ 下，事务 2 会被阻塞，因为事务 1 锁定了间隙 [10, MAX]。
-- 在 READ COMMITTED 下，事务 2 可以成功执行。
```

**总结：**

- 在 REPEATABLE READ 下，间隙锁的存在会阻止其他事务插入数据，增加了锁争用。
- 在 READ COMMITTED 下，间隙锁被禁用，只锁定实际访问的行，减少了锁的争用。



### **1.2 锁的持有时间差异**

- REPEATABLE READ：
  - 当前读和写操作的锁会持续到事务结束，确保事务读取的一致性。
  - 即使数据已经被读取完毕，锁仍然保留，导致其他事务需要等待。
- READ COMMITTED：
  - 锁在读取或修改操作完成后立即释放，不会持续到事务结束。
  - 这显著减少了锁的持有时间。

#### **示例：锁的持有时间对并发的影响**

```
sql复制代码-- 事务 1：
START TRANSACTION;
SELECT * FROM orders WHERE id = 10 FOR UPDATE;
-- 锁住了 id=10 的行

-- 事务 2：
START TRANSACTION;
UPDATE orders SET name = 'updated' WHERE id = 10;
-- 在 REPEATABLE READ 下，事务 2 会被阻塞，直到事务 1 提交。
-- 在 READ COMMITTED 下，事务 1 的锁会在 SELECT 执行后立即释放，事务 2 可以继续执行。
```

**总结：**

- 在 READ COMMITTED 下，锁的持有时间更短，减少了其他事务的等待时间。

### **1.3 当前读与写操作的灵活性**

- READ COMMITTED：
  - 当前读操作仅锁定实际访问的记录，不会锁定范围或额外的行。
  - 事务间的读写冲突减少，允许更高的并发性。
- REPEATABLE READ：
  - 当前读不仅锁定目标行，还可能引入间隙锁或范围锁，增加锁争用。



### **总结原因：**

1. **间隙锁的禁用：** 在 READ COMMITTED 下，不再使用间隙锁，减少了范围锁争用。
2. **锁持有时间更短：** 在 READ COMMITTED 下，锁在操作完成后立即释放，而不是等到事务结束。
3. **减少对一致性视图的约束：** READ COMMITTED 每次读取时刷新一致性视图，减少了对资源的长期占用。

### **适用场景：**

- 在高并发写入和范围查询的场景中，使用 READ COMMITTED 可以减少锁争用，提高吞吐量。
- 在数据一致性要求较低的场景下（如日志系统或非关键业务），READ UNCOMMITTED 可以进一步减少锁使用。

# 疑问

减少对一致性视图的约束： READ COMMITTED 每次读取时刷新一致性视图，减少了对资源的长期占用。 这个我很奇怪，这有什么资源占用呀，读已提交还一直在生成一致性视图，不更占用资源么？

------

## **1. 什么是一致性视图？**

一致性视图（Consistent Read View）是 **MVCC**（多版本并发控制）中的核心概念，用于实现事务的快照读。它记录了事务在读取数据时可见的版本。对于 InnoDB：

- 一致性视图存储了：
  - 当前活跃事务的 ID 列表（active transaction list）。
  - 最小活跃事务 ID 和下一个可分配的事务 ID，用于判断数据版本的可见性。

------

## **2. REPEATABLE READ 与 READ COMMITTED 的一致性视图行为**

### **2.1 REPEATABLE READ 的一致性视图**

- **生成时机：**一致性视图在事务第一次读取数据时生成。
- **生命周期：**整个事务期间，这个视图保持不变。
- 行为特点：
  - **一致性视图稳定：**所有快照读操作（普通 `SELECT`）都使用同一个视图，无需重新生成。
  - **成本：**虽然视图生成一次，但它在整个事务中必须保持有效，可能会导致 Undo Log 长时间保留，影响性能和存储。

### **2.2 READ COMMITTED 的一致性视图**

- **生成时机：**每次执行快照读时都生成新的视图。
- **生命周期：**视图仅在当前查询期间有效，查询结束后即丢弃。
- 行为特点：
  - **一致性视图动态更新：**每次读取都可以看到其他事务已提交的数据。
  - **成本：**每次查询都要生成新的视图，但每次查询结束后视图即可释放，不需要长期保留。

------

## **3. 为什么 READ COMMITTED 减少了资源的长期占用？**

从存储和操作的角度看，READ COMMITTED 确实减少了资源的长期占用，具体原因如下：

### **3.1 Undo Log 的使用时间缩短**

- **REPEATABLE READ：**
  - 一致性视图固定，意味着事务需要保持访问的历史版本可用。
  - 数据版本通过 Undo Log 记录。如果一个事务长时间运行，其他事务的更新操作会导致 Undo Log 堆积，因为这些旧版本不能被清理。
  - **结果：**Undo Log 空间占用增加，事务间的访问开销变大。
- **READ COMMITTED：**
  - 每次查询重新生成视图，不依赖事务开始时的旧版本。
  - 每个查询完成后，历史版本可能立刻被清理。
  - **结果：**Undo Log 的生命周期缩短，减少了历史版本的保留时间和存储开销。

------

### **3.2 活跃事务列表的开销减少**

- **REPEATABLE READ：**
  - 一致性视图中记录了所有活跃事务的列表。这些信息需要在整个事务生命周期内保持，事务越长，视图维护的成本越高。
- **READ COMMITTED：**
  - 一致性视图只在单个查询期间有效，事务活跃列表只需临时使用，查询结束后即可释放。
  - **结果：**减少了视图管理的内存和计算开销。

------

### **3.3 事务冲突和锁等待减少**

- **REPEATABLE READ：**
  - 长时间运行的事务由于持有固定的一致性视图，会增加与其他事务的冲突概率。例如：
    - 一个长事务会阻止其他事务清理 Undo Log，影响整体性能。
    - 写操作（如 `UPDATE`）可能需要等待长事务完成。
- **READ COMMITTED：**
  - 每次查询获取最新的已提交版本，不依赖事务开始时的视图。
  - **结果：**减少了事务间的冲突和锁等待问题。

------

## **4. 每次生成一致性视图的成本是否更高？**

虽然 READ COMMITTED 每次查询都需要生成新的视图，但从整体资源开销来看，这种方式的成本是相对可控的，主要原因如下：

### **4.1 一致性视图的生成成本较低**

- 一致性视图本质上是事务活跃状态的一个快照，生成的过程主要是读取当前活跃事务列表，这个操作的开销很小。

### **4.2 避免了 Undo Log 的长时间堆积**

- REPEATABLE READ 虽然一致性视图生成一次，但需要长时间保留旧版本数据，这对存储和清理都会产生额外开销。
- READ COMMITTED 则避免了这些问题。

### **4.3 查询效率的提升**

- READ COMMITTED 动态视图可以立即反映已提交的数据，减少了等待和冲突，提高了并发查询效率。

------

## **5. 总结**

虽然 READ COMMITTED 每次查询都生成新的一致性视图，但它通过减少 Undo Log 的保留时间和事务间冲突，显著降低了长期资源占用：

1. **减少 Undo Log 长期存储的压力。**
2. **减少活跃事务列表的维护开销。**
3. **减少事务间的锁冲突和等待问题。**

因此，在高并发和短事务场景中，READ COMMITTED 是一个性能更优的隔离级别，其一致性视图的动态生成不会显著增加系统开销，反而降低了资源的长期占用。
