---
layout: post
title:  "多版本并发控制最通俗化理解及深入分析"
date:   2024-11-19 18:49:41 +0800
categories: MYSQL
tags: [MYSQL]
---
![描述图片](/asset/img/1.png)
<audio controls autoplay>
  <source src="/asset/mp3/a2.mp3" type="audio/mpeg">
</audio>

MySQL 的 **MVCC**（Multi-Version Concurrency Control，多版本并发控制）是一种用于解决数据库中并发事务问题的技术。它通过保存数据的多个版本，允许读取操作和写入操作并发执行，从而减少锁的使用，提高数据库性能。MVCC 的核心思想是每个事务可以看到数据的不同版本，从而实现高效的并发控制。

# 初次见面

好的，我用一个生活中的比喻来帮你理解 MySQL 的 MVCC 概念！

### **情景剧：图书馆借书系统**

![](https://bpic.588ku.com/back_origin_min_pic/23/04/19/6c666e6abd3d44d71eb144f9b0bb1b61.jpg)

### 场景描述

想象一下，你去图书馆借书，但图书馆很忙，有很多人同时在借书（事务并发）。馆员为了保证每个人借书的时候不互相打扰，设计了一套聪明的系统，这个系统就像 MVCC。

### **系统规则**

1. **每本书有多个版本**：
   - 书架上可能有一本《数据库系统概论》。
   - 如果有人借走后修改了这本书，图书馆不会直接改动这本书，而是创建一个新的版本，把新的内容写进去。
   - 老版本依然保留，其他人还可以继续读老版本。
2. **每个借书人（事务）都有自己的时间线**：
   - 当你进入图书馆时，馆员给你一个“时间戳”（事务的开始时间）。
   - 你可以看到在你进入图书馆之前写好的书（符合你时间线的版本）。
   - 但如果有人在你进来之后才写的新书，你是看不到的，除非你重新进入图书馆。
3. **一致性视图（你的书单）**：
   - 你进门时，馆员帮你制作了一份书单（一致性视图），上面写明了你可以看到的所有书的版本。
   - 你借书时，会根据这份书单找对应的版本，不会理会别人正在修改的新版本。
4. **回滚指针（旧书保存）**：
   - 如果有人改了一本书的内容，图书馆会把老版本的书放到“旧书架”上（类似回滚段）。
   - 这样，其他人还是可以找到这些老版本。

### **具体行为**

1. **快照读（正常借书）**：
   - 你只是借书，并不打算修改。
   - 比如你想看《数据库系统概论》，馆员会根据你的时间戳，拿给你当时版本的书。
   - 即使其他人改了这本书，你也只看你自己那一刻的版本。
2. **当前读（直接修改）**：
   - 你不仅想借书，还打算在书上写笔记。
   - 馆员会让你拿最新的版本（当前版本），并且在你写的时候，其他人不能动这本书（加锁）。
3. **事务隔离级别影响**：
   - **READ COMMITTED**：每次借书都会生成一份最新的书单，你总能看到最新的版本（已提交的版本）。
   - **REPEATABLE READ**：你的书单在你进门时就固定了，整个过程中都只看那一份书单。
   - **READ UNCOMMITTED**：你甚至能看到别人正在修改还没提交的版本（可能内容还不完整）。
   - **SERIALIZABLE**：馆员只允许一个人借书或改书，其他人必须排队。

### **总结**

- 图书馆是数据库。
- 书是数据，每次修改会产生一个版本。
- 馆员管理的时间线和书单就是 MVCC 的核心：谁看到哪个版本的书完全取决于进入图书馆时的“时间戳”和规则。



<img src="https://img.lovepik.com/free-png/20210918/lovepik-interrogative-boy-png-image_400218942_wh1200.png" style="zoom:33%;" />

> 说完了吗？这尼玛，我还是不懂啊，说了等于白说一样。



**我一直有一个不解的地方 ，就是mvcc用多个版本，怎么保证一致性呢，比如我现在三个事务都去增加一条就得balance？**



# 深入沟通

### **问题描述**

假设你有一个 `balance` 字段，初始值是 100，有三个事务同时对它进行操作：

- **事务A**：增加 10。
- **事务B**：增加 20。
- **事务C**：增加 30。

最后，`balance` 应该是 **160**（100 + 10 + 20 + 30）。

问题是，如果这些事务看到的版本不一样，或执行顺序有冲突，怎么保证最终一致性？



### **MVCC 的一致性保证方式**

#### 1. **事务隔离性**

MVCC 的设计目标是：即使多个事务同时操作，它们的执行效果与**串行化执行**一致。这是通过以下规则实现的：

- 每个事务在操作数据时，都会看到一个独立的“版本快照”。
- 修改操作（写入）会基于事务的“当前读”（获取最新版本并加锁）。
- 提交时会确保修改数据的版本正确。

#### 2. **写入时的冲突检测**

当事务提交时，InnoDB 会检查：

- 该事务修改的数据是否被其他事务修改过（基于事务 ID 和版本号）。
- 如果没有冲突，事务可以提交，生成新的数据版本。
- 如果有冲突，事务需要回滚或重试。

#### 3. **多个事务写入的处理**

在具体实现中，`balance` 增加操作的逻辑如下：

- 事务A

  ：

  - 读取当前版本 `balance=100`。
  - 计算 `balance + 10 = 110`。
  - 写入新版本（带事务ID）。

- 事务B

  ：

  - 读取当前版本 `balance=100`（事务视图内的值）。
  - 计算 `balance + 20 = 120`。
  - 写入新版本（带事务ID）。

- 事务C

  ：

  - 读取当前版本 `balance=100`（事务视图内的值）。
  - 计算 `balance + 30 = 130`。
  - 写入新版本（带事务ID）。

最终提交时，InnoDB 需要解决这些写入的冲突：

- 基于行锁（行级别写入锁）

  ：

  - 只有一个事务可以成功提交它的写入，其他事务需要等待或回滚。
  - 比如，事务A提交后，其新版本（`balance=110`）成为最新值。
  - 事务B 和 事务C 在提交前会基于最新版本重新计算并提交。

这是一个好问题！当多个事务同时对相同的数据进行增删改（例如增加余额），**MVCC 如何保证一致性** 是它设计的关键之一。我们可以逐步分析。

------

### **问题描述**

假设你有一个 `balance` 字段，初始值是 100，有三个事务同时对它进行操作：

- **事务A**：增加 10。
- **事务B**：增加 20。
- **事务C**：增加 30。

最后，`balance` 应该是 **160**（100 + 10 + 20 + 30）。

问题是，如果这些事务看到的版本不一样，或执行顺序有冲突，怎么保证最终一致性？

------

### **MVCC 的一致性保证方式**

#### 1. **事务隔离性**

MVCC 的设计目标是：即使多个事务同时操作，它们的执行效果与**串行化执行**一致。这是通过以下规则实现的：

- 每个事务在操作数据时，都会看到一个独立的“版本快照”。
- 修改操作（写入）会基于事务的“当前读”（获取最新版本并加锁）。
- 提交时会确保修改数据的版本正确。

#### 2. **写入时的冲突检测**

当事务提交时，InnoDB 会检查：

- 该事务修改的数据是否被其他事务修改过（基于事务 ID 和版本号）。
- 如果没有冲突，事务可以提交，生成新的数据版本。
- 如果有冲突，事务需要回滚或重试。

#### 3. **多个事务写入的处理**

在具体实现中，`balance` 增加操作的逻辑如下：

- 事务A

  ：

  - 读取当前版本 `balance=100`。
  - 计算 `balance + 10 = 110`。
  - 写入新版本（带事务ID）。

- 事务B

  ：

  - 读取当前版本 `balance=100`（事务视图内的值）。
  - 计算 `balance + 20 = 120`。
  - 写入新版本（带事务ID）。

- 事务C

  ：

  - 读取当前版本 `balance=100`（事务视图内的值）。
  - 计算 `balance + 30 = 130`。
  - 写入新版本（带事务ID）。

最终提交时，InnoDB 需要解决这些写入的冲突：

- 基于行锁（行级别写入锁）

  ：

  - 只有一个事务可以成功提交它的写入，其他事务需要等待或回滚。
  - 比如，事务A提交后，其新版本（`balance=110`）成为最新值。
  - 事务B 和 事务C 在提交前会基于最新版本重新计算并提交。

------

### **完整案例：串行化效果模拟**

假设事务提交的顺序是 A -> B -> C，实际执行会变成这样：

1. **事务A**：
   - 读取 `balance=100`。
   - 增加 10，更新为 `balance=110`。
   - 提交成功。
2. **事务B**：
   - 提交前检测发现事务A已经提交，`balance` 最新值为 `110`。
   - 重新计算：`110 + 20 = 130`。
   - 提交成功。
3. **事务C**：
   - 提交前检测发现事务B已经提交，`balance` 最新值为 `130`。
   - 重新计算：`130 + 30 = 160`。
   - 提交成功。

最终，`balance` 的值正确更新为 **160**。

### **关键点总结**

1. **一致性保障**：
   - MVCC 保证写操作时，修改基于最新的版本（当前读 + 加锁）。
   - 提交时进行冲突检测，必要时回滚或重试。
2. **避免问题的方法**：
   - 写操作需要加锁（如 `SELECT FOR UPDATE`）。
   - 修改时基于当前版本，避免修改老版本引发冲突。
3. **最终一致性**：
   - 即使事务并发，最终结果与事务串行执行一致（这是事务的隔离级别保证的）。



**这我有点不理解了，你是不是说错了，还在提交前获取最新值？**

<img src="https://img.lovepik.com/free-png/20210918/lovepik-interrogative-boy-png-image_400218942_wh1200.png" style="zoom:33%;" />



**在 MVCC 中，事务在提交前不会主动获取最新值**，因为事务的核心规则是**基于快照视图的一致性**，而不是实时查看最新数据。这种行为只会发生在需要冲突检测的时候（如加锁写入）。让我重新解释并理清这个问题。

------

### **事务提交与 MVCC 的真正行为**

MVCC 的本质是通过维护**多个版本的记录**，保证在事务并发的情况下，每个事务看到的数据是一致的。事务在操作过程中基于其自己的快照视图进行读写，只有在提交阶段，才会进行冲突检测。

#### 重点：事务在提交前**不会重新获取最新值**。

- 如果事务执行过程中使用了快照读，那么它永远基于事务开始时的快照。
- 如果事务执行过程中使用了当前读（比如 `SELECT ... FOR UPDATE`），它会锁住数据行，但依然操作的是事务当前上下文中的数据。

------

### **为什么事务不会重新获取最新值**

1. **事务的隔离性保证**：
   - 在事务隔离级别为 **REPEATABLE READ** 或 **READ COMMITTED** 时，事务读取的数据是基于一致性快照视图的。
   - 如果事务在提交前重新获取最新值，会破坏事务的隔离性，因为其他事务的修改会影响到当前事务。
2. **冲突检测机制**：
   - 当事务尝试提交修改时，数据库会检查：
     - 修改的数据是否已经被其他事务修改过。
     - 如果有冲突，事务回滚或重试，而不是重新读取数据。
3. **并发控制的原则**：
   - MVCC 通过版本链和回滚段（Undo Log）来管理数据的多个版本。
   - 事务的修改始终基于启动时的快照视图，写入时创建新的版本。
   - 不会主动调整为“最新值”。

------

### **正确的行为示例**

以增加余额为例，假设 `balance = 100`，三个事务并发操作：

1. **事务A**：
   - 开始事务，读取 `balance=100`。
   - 计算 `balance+10=110`。
   - 写入新版本（版本号为A）。
   - 提交。
2. **事务B**：
   - 开始事务，读取 `balance=100`（事务视图内的值）。
   - 计算 `balance+20=120`。
   - 写入新版本（版本号为B）。
   - 提交。
3. **事务C**：
   - 开始事务，读取 `balance=100`（事务视图内的值）。
   - 计算 `balance+30=130`。
   - 写入新版本（版本号为C）。
   - 提交。

这三个事务各自基于它们的视图完成修改，最终提交的结果：

- **事务A** 提交后，`balance=110`。
- **事务B** 提交时，检测到事务A已提交，可能导致冲突，因此事务B需要**回滚并重试**，重新基于最新值 `balance=110` 再计算：`110+20=130`。
- **事务C** 也需要基于最新值 `balance=130` 计算 `130+30=160`。

最终结果：`balance=160`。

------

### **总结核心点**

1. **事务中不会重新获取最新值**：
   - 在事务执行过程中，读取的数据始终基于快照视图。
   - 即使其他事务提交，当前事务也不会感知到这些变化。
2. **提交时进行冲突检测**：
   - 当事务提交时，MySQL 会检查写入的数据是否与其他事务发生冲突（通过行锁或版本号）。
   - 如果冲突，事务需要回滚或重试，基于最新的值重新进行写入。
3. **一致性由提交阶段保证**：
   - 每个事务独立处理自己的快照视图，最终通过冲突检测和回滚机制确保一致性。

MVCC 的核心目标就是在提高并发性能的同时，保持数据的一致性。事务之间的“隔离性”和最终“一致性”是通过快照视图、版本控制和提交阶段的冲突检测共同实现的。

# 顿悟

<img src="https://p6.itc.cn/q_70/images03/20201006/2c2a27091d8a4a51b716b8cb04cbeb4a.jpeg" style="zoom:25%;" />



**说这么多，核心思想就是，mvcc会基于自己的版本去进行预先计算最终结果，但是在提交之前，会判断我的我需要提交的记录是不是被修改过，如果被修改，那就回滚，重新计算，这不就是乐观锁，再加上重试的机制嘛**



### **MVCC 核心思想**

1. **多版本管理**：
   - 每行记录维护多个版本（通过隐藏列或回滚段）。
   - 事务读取时根据一致性视图获取符合自己快照的版本。
2. **冲突检测**：
   - 提交时判断是否存在冲突（即数据是否被其他事务修改过）。
   - 如果有冲突，回滚当前事务，或者重试（类似乐观锁的机制）。
3. **提高并发性能**：
   - 读操作不会加锁，直接通过快照版本读取数据。
   - 写操作需要加锁，但加锁范围和时间都尽量小。

------

### **MVCC 和乐观锁的关系**

#### **相似点**

1. **基于版本控制**：
   - 乐观锁通常使用一个“版本号”或“时间戳”来标识数据的状态。
   - MVCC 使用事务版本号（或行的修改时间）来管理记录的多个版本。
2. **冲突检测**：
   - 乐观锁在更新数据时，检查版本号是否变化。
   - MVCC 在提交数据时，检查修改的数据是否被其他事务改动。
3. **回滚与重试**：
   - 乐观锁在版本冲突时会回滚并重试。
   - MVCC 的事务冲突也会触发回滚，要求重试或报错。

#### **不同点**

1. **实现复杂性**：
   - 乐观锁依赖一个简单的“版本号”字段，逻辑较为简单。
   - MVCC 需要维护多个数据版本、隐藏列和回滚段，逻辑更复杂。
2. **适用场景**：
   - 乐观锁更适合写操作较少的场景，冲突概率低。
   - MVCC 通过快照读极大地提升了读操作的性能，适合读多写少的场景。
3. **隔离级别支持**：
   - 乐观锁无法直接实现事务的隔离级别控制（需要额外机制）。
   - MVCC 本身支持事务的隔离级别（如 `READ COMMITTED` 和 `REPEATABLE READ`）。
4. **锁的使用**：
   - 乐观锁完全不加锁，依赖冲突检测。
   - MVCC 的读操作无锁，但写操作仍需要加锁以防止提交阶段的竞争。

------

### **总结**

你说得对，MVCC 在某种程度上可以理解为一种更复杂的乐观锁机制，但它不仅仅是乐观锁。MVCC 的核心亮点在于：

1. **读写并发**：通过多版本实现读写分离，减少锁的使用，提高并发性能。
2. **隔离性保障**：不同事务可以基于自己的快照独立运行，同时提交阶段通过冲突检测保障一致性。
3. **更适合数据库场景**：相比单纯的乐观锁，MVCC 更加适配高并发数据库环境的需求。

所以，MVCC 是一种基于乐观锁思想的高级实现，结合了事务的隔离级别、多版本管理和冲突检测机制，是数据库系统为实现高效并发控制的一个巧妙设计。



## **mysql默认使用mvcc还是用锁？**



### **默认使用 MVCC 的情况**

1. **快照读（Snapshot Read）**：

   - 快照读是指事务读取基于 MVCC 提供的“快照视图”的数据，而不加锁。

   - 常见的 SQL 操作如 `SELECT`（不带 `FOR UPDATE` 或 `LOCK IN SHARE MODE`）默认是快照读。

   - 适用场景

     ：

     - 在事务隔离级别为 `READ COMMITTED` 或 `REPEATABLE READ` 时，快照读是 MVCC 的默认行为。

     - 例如：

       ```
       sql
       
       
       复制代码
       SELECT * FROM accounts WHERE id = 1;
       ```

     - 此时读取的是 MVCC 提供的一致性视图中的数据。

2. **事务隔离级别**：

   - `READ COMMITTED` 和 `REPEATABLE READ` 主要依赖 MVCC 来提供数据的隔离性。
   - 在这些隔离级别下，读取操作不会阻塞写入操作，因为读取基于快照视图，而不是实时数据。

### **使用锁的情况**

尽管 MySQL 默认使用 MVCC，但在某些情况下会切换到锁机制，例如：

1. **当前读（Current Read）**：

   - 当前读是指直接读取最新的数据版本，并对数据加锁，确保其他事务不能同时修改该数据。

   - 常见的操作包括：

     - `SELECT ... FOR UPDATE`（加排他锁，阻止其他事务修改）。
     - `SELECT ... LOCK IN SHARE MODE`（加共享锁，允许其他事务读取但不允许修改）。
     - `UPDATE`、`DELETE` 和 `INSERT` 等写操作。

     示例：

     ```
     SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
     ```

     - 此操作会锁住 `id=1` 的行，其他事务无法修改这条记录。

2. **高隔离级别**：

   - 在 `SERIALIZABLE` 隔离级别下，所有的 `SELECT` 操作都会被当作当前读，并加锁，以保证事务的严格串行化执行。

3. **锁的类型**：

   - **行锁**（Row Lock）：在行级别操作时加锁。
   - **表锁**（Table Lock）：某些场景（如 `ALTER TABLE`）会锁住整张表。

------

### **总结**

- 默认行为：
  - **MySQL 默认使用 MVCC**，特别是在 `SELECT` 等读操作中，通过快照视图避免加锁，提高并发性能。
- 使用锁的场景：
  - **写操作**（`INSERT`、`UPDATE`、`DELETE`）。
  - **显式加锁读**（`SELECT ... FOR UPDATE` 或 `LOCK IN SHARE MODE`）。
  - **高隔离级别**（`SERIALIZABLE`）。

所以，**默认使用 MVCC，但根据操作的类型和隔离级别，MySQL 会在需要时切换到锁机制**，以确保数据的一致性和隔离性。

## **SELECT ... FOR UPDATE 或 LOCK IN SHARE MODE 这两个有啥区别呀**

`SELECT ... FOR UPDATE` 和 `SELECT ... LOCK IN SHARE MODE` 都是 MySQL 中的**当前读**（Current Read），它们会对查询的行加锁以避免并发写入，但两者在锁的类型和适用场景上有所区别。

------

### **1. `SELECT ... FOR UPDATE`**

#### **作用**：

- 对查询返回的行加**排他锁**（Exclusive Lock）。
- 排他锁的特点是：其他事务无法对这些行执行任何修改（如 `UPDATE` 或 `DELETE`），但可以进行非锁定的快照读（普通 `SELECT`）。

#### **使用场景**：

- 用于需要修改选中数据的场景，通常是为了避免“丢失更新”问题。

- 示例：

  ```
  sql复制代码BEGIN;
  SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;
  UPDATE accounts SET balance = balance + 100 WHERE id = 1;
  COMMIT;
  ```

  以上事务：

  - 在读取 `balance` 时锁住 `id=1` 的行。
  - 其他事务尝试修改或删除 `id=1` 的行时，会被阻塞，直到当前事务提交或回滚。

#### **特点**：

- 会阻塞其他事务的写操作和 `LOCK IN SHARE MODE` 操作。
- 通常用于**强一致性需求**的场景，比如确保读取后数据未被其他事务修改。

------

### **2. `SELECT ... LOCK IN SHARE MODE`**

#### **作用**：

- 对查询返回的行加**共享锁**（Shared Lock）。
- 共享锁的特点是：允许其他事务对这些行加共享锁（多事务可以同时读取），但禁止加排他锁（例如 `UPDATE` 或 `DELETE`）。

#### **使用场景**：

- 用于确保读取的数据在当前事务提交前**不被修改或删除**，但不会阻止其他事务读取。

- 示例：

  ```
  sql复制代码BEGIN;
  SELECT balance FROM accounts WHERE id = 1 LOCK IN SHARE MODE;
  -- 数据一致性校验逻辑
  COMMIT;
  ```

  以上事务：

  - 在读取 `balance` 时锁住 `id=1` 的行。
  - 其他事务可以读取，但无法修改或删除该行。

#### **特点**：

- 会阻止其他事务的写操作（加排他锁），但允许读操作或加共享锁。
- 通常用于**一致性校验**的场景，比如在读取某行数据后执行某些逻辑，但不直接修改数据。

------

### **两者的区别**

| 特性                     | `SELECT ... FOR UPDATE`            | `SELECT ... LOCK IN SHARE MODE`      |
| ------------------------ | ---------------------------------- | ------------------------------------ |
| **锁类型**               | 排他锁（Exclusive Lock）           | 共享锁（Shared Lock）                |
| **是否允许其他事务读取** | 允许快照读，但不能加任何锁         | 允许快照读和加共享锁，但不能加排他锁 |
| **是否允许其他事务修改** | 不允许（阻塞所有写操作）           | 不允许（阻塞 `UPDATE` 和 `DELETE`）  |
| **主要用途**             | 用于读取后修改数据，防止并发写操作 | 用于确保数据在读取后未被修改或删除   |
| **使用场景**             | 需要强一致性，防止丢失更新         | 数据校验场景，读取后无直接修改需求   |

------

### **选择哪种？**

- **`FOR UPDATE`**：当你读取数据后**需要修改**它（比如事务更新余额）。
- **`LOCK IN SHARE MODE`**：当你读取数据只是为了**验证一致性**，但不打算修改它（比如校验某行是否满足条件）。

------

### **注意事项**

1. 如果使用 `LOCK IN SHARE MODE` 或 `FOR UPDATE`，记得设置事务隔离级别为 **`REPEATABLE READ`** 或更高，以确保读取的数据在事务期间不会变化。
2. 如果查询未返回行，MySQL 不会加锁。
3. 在 **InnoDB** 存储引擎中，这些锁通常是行锁（Row Lock），但如果查询涉及范围扫描，可能会导致间隙锁（Gap Lock）。

# 更输入理解

结合**图书馆借书的例子**，用通俗易懂的方式来讲解 **READ COMMITTED**（读已提交）和 **REPEATABLE READ**（可重复读）隔离级别中的 **Read View**（一致性视图）机制。以下例子会确保**原理准确**，并用图书馆场景化帮助理解

### **场景设定**

- 图书馆的书架上有一本《数据库系统概论》。
- 不同借书人对应不同的事务。
- 馆员会根据借书人的“借书规则”（隔离级别）决定借书时提供哪一版本的书。
- **Read View** 是借书人进馆时馆员为他们制作的一份“借书清单”（即快照），决定借书人能看到哪些书的版本。

### **READ COMMITTED（读已提交）：不断刷新书单**

#### **规则**：

在 **读已提交** 隔离级别中，馆员会在**每次借书时**为借书人重新检查书架上的书。也就是说：

- 你只能看到已经“摆到书架上的书”（提交的版本）。
- 别人正在修改或未提交的书，你是看不到的。
- 每次借书，馆员都会重新生成一份书单。

#### **例子**：

1. **初始状态**：
   - 图书馆书架上有《数据库系统概论 v1》，写着“作者：张三”。
   - 借书人A（事务A）进入图书馆。
   - 借书人B（事务B）进入图书馆，决定更新这本书。
2. **事务B修改书**：
   - 借书人B把书拿下来改成“作者：李四”，但还没放回书架（未提交）。
3. **事务A借书**：
   - 借书人A要求借《数据库系统概论》。
   - 馆员查看书架，发现书还是 `v1` 版本（因为事务B未提交）。
   - 馆员把《数据库系统概论 v1》借给了事务A。
4. **事务B提交修改**：
   - 借书人B完成修改，把《数据库系统概论 v2》（“作者：李四”）放回书架并提交。
5. **事务A再次借书**：
   - 事务A又要求借一次《数据库系统概论》。
   - 这次，馆员重新检查书架，发现书已经更新为 `v2` 版本。
   - 馆员把《数据库系统概论 v2》借给了事务A。

#### **总结**：

在 **READ COMMITTED** 隔离级别中，借书人每次借书都看到最新已提交的版本（书单实时刷新）。但如果有其他事务在修改书，还未提交，借书人是无法看到这些未提交的更改。

------

### **REPEATABLE READ（可重复读）：固定书单**

#### **规则**：

在 **可重复读** 隔离级别中，馆员只在借书人进入图书馆的**第一次**为他们制作一份“书单”（一致性视图）。整个借书过程，借书人只能看到这份书单中的书，无论书架上的书后来如何变化。

#### **例子**：

1. **初始状态**：
   - 图书馆书架上有《数据库系统概论 v1》，写着“作者：张三”。
   - 借书人A（事务A）进入图书馆。
   - 借书人B（事务B）进入图书馆，决定更新这本书。
2. **事务A的书单**：
   - 馆员为借书人A生成一份书单，其中《数据库系统概论 v1》写着“作者：张三”。
3. **事务B修改书**：
   - 借书人B把书拿下来改成“作者：李四”，但还没放回书架（未提交）。
4. **事务A借书**：
   - 借书人A要求借《数据库系统概论》。
   - 馆员按照事务A的书单，给了 `v1` 版本的书（因为事务A只能看到进入图书馆时的快照）。
5. **事务B提交修改**：
   - 借书人B完成修改，把《数据库系统概论 v2》（“作者：李四”）放回书架并提交。
6. **事务A再次借书**：
   - 借书人A又要求借一次《数据库系统概论》。
   - 馆员依然按照事务A的书单，给了 `v1` 版本的书，尽管书架上已经更新为 `v2` 版本。

#### **总结**：

在 **REPEATABLE READ** 隔离级别中，借书人只能看到进入图书馆时的那一份书单（快照视图）。即使书架上的书被其他人修改并提交，借书人也无权看到这些修改。

------

### **核心区别**

| 特性                      | READ COMMITTED （读已提交）                | REPEATABLE READ （可重复读）           |
| ------------------------- | ------------------------------------------ | -------------------------------------- |
| **书单（Read View）生成** | 每次借书时重新生成                         | 进入图书馆时生成一次，整个事务期间不变 |
| **是否看到最新提交数据**  | 每次借书时可看到最新的已提交数据           | 始终只能看到事务开始时的数据版本       |
| **适用场景**              | 数据读取实时性要求较高，但不关注前后一致性 | 需要确保多次读取结果一致               |

------

### **总结**

1. **READ COMMITTED**：书单动态更新，每次借书都看到最新已提交版本。
2. **REPEATABLE READ**：书单固定，事务期间看到的书版本始终一致，哪怕其他人已经修改并提交了新版本。

希望这个图书馆的例子让你对 **READ VIEW** 的机制在两种隔离级别中的表现更加清晰！如果还有不理解的地方，随时可以问我！





**整个过程都是说的读的过程，假如事务A 有写的操作，还是会因为冲突检测到有修改，从而重试，然后获取到最新的版本，基于最新版本更新数据**



在事务中如果有写操作，确实需要额外考虑冲突检测。**这部分涉及 MVCC 的核心机制之一：**写操作与冲突检测如何协同工作**。

我们在原有的图书馆场景基础上，再加入写操作的过程，说明写入操作如何影响 MVCC 的行为。





### **写操作的行为**

1. 写操作的关键点

   ：

   - 写操作（如 `UPDATE` 或 `DELETE`）需要获取**当前最新版本**的数据（通过当前读 `SELECT ... FOR UPDATE`），并对其加锁。
   - 写操作不会使用事务开始时的快照视图，而是直接读取当前最新版本。
   - 在提交时，MySQL 会检测数据是否被其他事务修改过。如果发现冲突，事务会回滚或报错，开发者需要根据情况决定是否重试。

------

### **扩展场景：事务A 有写操作**

#### **初始状态**

- 图书馆书架上有《数据库系统概论》，版本为 `v1`（“作者：张三”）。
- 借书人A（事务A）和借书人B（事务B）进入图书馆：
  - 借书人A计划增加书的页数（写操作）。
  - 借书人B计划修改书的作者（写操作）。

------

#### **过程分析**

1. **事务A准备写操作**：
   - 借书人A告诉馆员：“我要修改这本书，增加 10 页。”
   - 馆员根据事务A的请求，使用 `SELECT ... FOR UPDATE` 锁住了《数据库系统概论》的当前版本（`v1`）。
   - 事务A持有这本书的锁，其他事务不能对其进行修改。
2. **事务B尝试写操作**：
   - 同时，借书人B告诉馆员：“我要修改这本书，把作者改为‘李四’。”
   - 馆员发现这本书已经被事务A锁住，于是阻塞事务B的操作，直到事务A完成。
3. **事务A完成修改**：
   - 借书人A修改完书，增加了 10 页，生成《数据库系统概论 v2》（“作者：张三，页数+10”）。
   - 事务A提交后，`v2` 被放回书架。
4. **事务B重新尝试**：
   - 事务B解除阻塞后，馆员告诉事务B：“这本书已经被修改了（事务A已提交新版本）。”
   - 事务B读取最新版本（`v2`），并基于 `v2` 进行修改：将作者改为“李四”，生成《数据库系统概论 v3》。
   - 事务B完成提交后，书架上的版本更新为 `v3`。

------

### **冲突检测与重试**

- **核心机制**：
  - 当事务尝试提交写操作时，InnoDB 会检查：
    1. 事务修改的数据行是否仍然是事务开始时读取的版本。
    2. 如果版本已经被其他事务修改（即发生冲突），当前事务会回滚，并报错（如 `ERROR 1213: Deadlock found`）。
  - 开发者可以捕获错误并选择是否重试。
- **重试机制**：
  - 如果开发者选择重试，则事务会重新读取最新版本的数据，并重新计算修改结果。
  - 例如，事务B在事务A提交后检测到冲突，则需要重新读取最新版本 `v2` 并基于此进行修改。

------

### **写操作的关键点总结**

1. **当前读获取最新版本**：
   - 写操作始终基于最新版本，而不是快照视图。这是通过 `SELECT ... FOR UPDATE` 或 `LOCK IN SHARE MODE` 实现的。
2. **冲突检测**：
   - 在事务提交时，如果发现其他事务已经修改了同一数据，当前事务会被回滚（乐观锁思想）。
   - 开发者可以选择重试，读取最新版本的数据进行更新。
3. **最终一致性**：
   - 虽然多个事务可能并发操作，但通过锁机制和冲突检测，MySQL 能保证写入操作的最终一致性，与事务串行化效果相同。

------

### **再结合图书馆的例子，给出总结**

1. **读操作**：
   - 事务A和事务B可以各自看到自己事务中的快照版本，互不影响。
   - 事务B即使提交了修改，事务A在没有写操作的情况下，仍然只看到事务开始时的快照视图。
2. **写操作**：
   - 事务A在写入时会锁住数据，其他事务无法同时修改该数据。
   - 事务B只能等事务A提交后，基于最新版本重新进行修改，确保数据一致性。